use crate::ast::*;

// lalrpop 里的约定
grammar;

// 约束 lexer 的行为
match {
  // 跳过空白符和注释
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*.*\*/" => {},    // 匹配 /* ... */
  // 剩下的情况采用默认方式处理
  _
}
pub Expression: Box<Expression> = {
  <exp: Exp> => Box::new(Expression::Exp{ <> }),
  <sexp: SExp> => Box::new(Expression::SExp{ <> }),
  <objattrexp: ObjAttrExp> => Box::new(Expression::ObjAttrExp{ <> }),
}
pub ObjAttrExp: Box<ObjAttrExp> = {
  "[" <sexp: SExp> "]" => Box::new(ObjAttrExp::From{ <> }),
}
pub Exp: Box<Exp> = <addexp: AddExp> => <>;
pub ExpConfig: Box<IExpConfig> = {
  <name: Ident> => Box::new(IExpConfig::From{ name: name }),
  <expconfig: ExpConfig>"("<id:Number>"->"<objtype:Ident>")" => Box::new(IExpConfig::Mk{ <> }),
}
pub SExp: Box<SExp> = {
  <expconfig: ExpConfig> "|-" <exp: Exp> => Box::new(SExp::Mk{ <> }),
}


MeasureType: Box<MeasureType> = {
  "[t_end=" <t_end: FloatConst> ",n=" <n: Number> ",repeat_time=" <repeat_time: Number> ",error=" <error: FloatConst> "]"
    => Box::new(MeasureType::new(<>)),
}

PrimaryExp: Box<Exp> = {
  <num: Number> => Box::new(Exp::Number{ <> }),
  <name: Ident> => Box::new(Exp::Variable{ <> }),
  <name: Ident>"["<id: Number>"]" => Box::new(Exp::VariableId{ <> }),
  "(" <exp: Exp> ")" => <>,
}

PowExp: Box<Exp> = {
  <primaryexp: PrimaryExp> => <>,
  <powexp: PowExp> "**" <primaryexp: PrimaryExp> =>
    Box::new(Exp::BinaryExp{ left: powexp, op: BinaryOp::Pow, right: primaryexp }),
  "D[" <powexp: PowExp> "]/D[" <primaryexp: PrimaryExp> "]" =>
    Box::new(Exp::DiffExp{ left: powexp, right: primaryexp, ord: 1 }),
  "D^" <ord: Number> "[" <powexp: PowExp> "]/D[" <primaryexp: PrimaryExp> "]^" <ord2: Number> => {
    assert!(ord == ord2);
    Box::new(Exp::DiffExp{ left: powexp, right: primaryexp, ord: ord })
  },
  <primaryexp: PrimaryExp> "'" =>
    Box::new(Exp::DiffExp{ left: primaryexp, right: Box::new(Exp::Variable{ name: "t".to_string() }), ord: 1 }),
  <primaryexp: PrimaryExp> "''" =>
    Box::new(Exp::DiffExp{ left: primaryexp, right: Box::new(Exp::Variable{ name: "t".to_string() }), ord: 2 }),
}

UnaryExp: Box<Exp> = {
  <powexp: PowExp> => <>,
  "-" <unaryexp: UnaryExp> =>
    Box::new(Exp::UnaryExp{ op: UnaryOp::Neg, exp: unaryexp }),
}

MulExp: Box<Exp> = {
  <unaryexp: UnaryExp> => <>,
  <mulexp: MulExp> "*" <unaryexp: UnaryExp> =>
    Box::new(Exp::BinaryExp{ left: mulexp, op: BinaryOp::Mul, right: unaryexp }),
  <mulexp: MulExp> "/" <unaryexp: UnaryExp> =>
    Box::new(Exp::BinaryExp{ left: mulexp, op: BinaryOp::Div, right: unaryexp }),
}

AddExp: Box<Exp> = {
  <mulexp: MulExp> => <>,
  <addexp: AddExp> "+" <mulexp: MulExp> =>
    Box::new(Exp::BinaryExp{ left: addexp, op: BinaryOp::Add, right: mulexp }),
  <addexp: AddExp> "-" <mulexp: MulExp> =>
    Box::new(Exp::BinaryExp{ left: addexp, op: BinaryOp::Sub, right: mulexp }),
}

WithExp: Box<Exp> = {
  <addexp: AddExp> => <>,
  <addexp: AddExp> "with" <measuretype: MeasureType> =>
    Box::new(Exp::ExpWithMeasureType{ exp: addexp, measuretype: measuretype }),
}


Number: i32 = <num: IntConst> => <>;

// 如果匹配到标识符, 就返回这个字符串
// 一对尖括号在此处指代的是正则表达式匹配到的字符串 (&str)
Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

// 对整数字面量的处理方式: 把匹配到的字符串按对应进制转换成数字
IntConst: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}

// copilot 写的
FloatConst: f64 = {
  r"[0-9]*\.[0-9]+" => (&<>).parse().unwrap(),
  r"[0-9]*\.[0-9]+[eE][+-]?[0-9]+" => (&<>).parse().unwrap(),
}