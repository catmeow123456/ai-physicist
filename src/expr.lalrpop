use crate::ast::*;

// lalrpop 里的约定
grammar;

// 约束 lexer 的行为
match {
  // 跳过空白符和注释
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*.*\*/" => {},    // 匹配 /* ... */
  // 剩下的情况采用默认方式处理
  _
}
pub Expression: Box<Expression> = {
  <exp: Exp> => Box::new(Expression::Exp{ <> }),
  <sexp: SExp> => Box::new(Expression::SExp{ <> }),
  <texp: TExp> => Box::new(Expression::TExp{ <> }),
  <objattrexp: ObjAttrExp> => Box::new(Expression::ObjAttrExp{ <> }),
  <prop: Proposition> => Box::new(Expression::Proposition{ <> }),
}
pub ObjAttrExp: Box<ObjAttrExp> = {
  "[" <sexp: SExp> "]" => Box::new(ObjAttrExp::From{ <> }),
}
pub Exp: Box<Exp> = <addexp: AddExp> => <>;
pub PrimaryProposition: Box<Proposition> = {
  "(" <proposition: Proposition> ")" => <>,
}
pub Proposition: Box<Proposition> = {
  <exp: Exp> "is" "conserved" => Box::new(Proposition::IsConserved{ <> }),
  <exp: Exp> "is" "zero" => Box::new(Proposition::IsZero{ <> }),
  <left: Exp> "=" <right: Exp> => Box::new(Proposition::Eq{ <> }),
  "not" <prop: PrimaryProposition> => Box::new(Proposition::Not{ <> }),
}
pub ExpConfig: Box<IExpConfig> = {
  "#"<name: Ident> => Box::new(IExpConfig::From{ name: name }),
  <expconfig: ExpConfig>"("<id:Number>"->"<objtype:Ident>")" => Box::new(IExpConfig::Mk{ <> }),
  <expconfig: ExpConfig>"["<id:Number>"->"<object:Ident>"]" => Box::new(IExpConfig::Mkfix{ <> }),
}
pub SExp: Box<SExp> = {
  <expconfig: ExpConfig> "|-" <exp: Exp> => Box::new(SExp::Mk{ <> }),
}
pub TExp: Box<TExp> = {
  "|-" <exp: Exp> => Box::new(TExp::Mk0{ <> }),
  // "(" <id:Number> "->" <objtype:Ident> ")" <texp: TExp> => Box::new(TExp::Mksucc{ <> }),
  <inttoidentvec: IntToIdentVec> "|-" <exp: Exp> => {
    let mut texp = TExp::Mk0{ exp };
    for (id, objtype) in inttoidentvec {
      texp = TExp::Mksucc{ id, objtype, texp: Box::new(texp) };
    }
    Box::new(texp)
  },
}


MeasureType: Box<MeasureType> = {
  "[t_end=" <t_end: FloatConst> ",n=" <n: Number> ",repeat_time=" <repeat_time: Number> ",error=" <error: FloatConst> "]"
    => Box::new(MeasureType::new(<>)),
}

PrimaryExp: Box<Exp> = {
  <num: Number> => Box::new(Exp::Number{ <> }),
  <atom: AtomExp> => Box::new(Exp::Atom{ <> }),
  "(" <exp: Exp> ")" => <>,
}

PowExp: Box<Exp> = {
  <primaryexp: PrimaryExp> => <>,
  <powexp: PowExp> "**" <primaryexp: PrimaryExp> =>
    Box::new(Exp::BinaryExp{ left: powexp, op: BinaryOp::Pow, right: primaryexp }),
  "D[" <left: Exp> "]/D[" <right: Exp> "]" =>
    Box::new(Exp::DiffExp{ left: left, right: right, ord: 1 }),
  "D^" <ord: Number> "[" <left: Exp> "]/D[" <right: Exp> "]^" <ord2: Number> => {
    assert!(ord == ord2);
    Box::new(Exp::DiffExp{ left: left, right: right, ord: ord })
  },
  <primaryexp: PrimaryExp> "'" =>
    Box::new(Exp::DiffExp{ left: primaryexp, right: Box::new(Exp::get_t()), ord: 1 }),
  <primaryexp: PrimaryExp> "''" =>
    Box::new(Exp::DiffExp{ left: primaryexp, right: Box::new(Exp::get_t()), ord: 2 }),
}

UnaryExp: Box<Exp> = {
  <powexp: PowExp> => <>,
  "-" <unaryexp: UnaryExp> =>
    Box::new(Exp::UnaryExp{ op: UnaryOp::Neg, exp: unaryexp }),
}

MulExp: Box<Exp> = {
  <unaryexp: UnaryExp> => <>,
  <mulexp: MulExp> "*" <unaryexp: UnaryExp> =>
    Box::new(Exp::BinaryExp{ left: mulexp, op: BinaryOp::Mul, right: unaryexp }),
  <mulexp: MulExp> "/" <unaryexp: UnaryExp> =>
    Box::new(Exp::BinaryExp{ left: mulexp, op: BinaryOp::Div, right: unaryexp }),
}

AddExp: Box<Exp> = {
  <mulexp: MulExp> => <>,
  <addexp: AddExp> "+" <mulexp: MulExp> =>
    Box::new(Exp::BinaryExp{ left: addexp, op: BinaryOp::Add, right: mulexp }),
  <addexp: AddExp> "-" <mulexp: MulExp> =>
    Box::new(Exp::BinaryExp{ left: addexp, op: BinaryOp::Sub, right: mulexp }),
}

WithExp: Box<Exp> = {
  <addexp: AddExp> => <>,
  <addexp: AddExp> "with" <measuretype: MeasureType> =>
    Box::new(Exp::ExpWithMeasureType{ exp: addexp, measuretype: measuretype }),
}

AtomExp: Box<AtomExp> = {
  <name: Ident> => Box::new(AtomExp::Variable{ <> }),
  <name: Ident>"["<ids: IntVecConst>"]" => Box::new(AtomExp::VariableIds{ <> }),
}

Number: i32 = <num: IntConst> => <>;

// 如果匹配到标识符, 就返回这个字符串
// 一对尖括号在此处指代的是正则表达式匹配到的字符串 (&str)
Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

IntToIdent: (i32, String) = {
  "(" <id:IntConst> "->" <objtype:Ident> ")" => (id, objtype),
}

IntToIdentVec: Vec<(i32, String)> = {
  <inttoident: IntToIdent> => vec![<>],
  <inttoidentvec: IntToIdentVec> <inttoident: IntToIdent> => {
    let mut inttoidentvec = inttoidentvec;
    inttoidentvec.push(inttoident);
    inttoidentvec
  },
}

IntVecConst: Vec<i32> = {
  <num: IntConst> => vec![<>],
  <numlist: IntVecConst> "," <num: IntConst> => {
    let mut numlist = numlist;
    numlist.push(num);
    numlist
  },
}

// 对整数字面量的处理方式: 把匹配到的字符串按对应进制转换成数字
IntConst: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}

// copilot 写的
FloatConst: f64 = {
  r"[0-9]*\.[0-9]+" => (&<>).parse().unwrap(),
  r"[0-9]*\.[0-9]+[eE][+-]?[0-9]+" => (&<>).parse().unwrap(),
}