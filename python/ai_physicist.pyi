from typing import List, Dict, Set
from deprecated.sphinx import deprecated

class AtomExp:
    """
    Represents an atomic expression in the language of the AI Physicist.
    For example, "pos[1]", "r[2, 3]", "t[0]" are all atomic expressions.
    """

    def __new__(cls, content: str) -> AtomExp: ...

    def __str__(self) -> str: ...

    def __hash__(self) -> int: ...

    def VariableIds(name: str, ids: List[int]) -> AtomExp:
        """
        Create an atomic expression with a variable name and a list of ids.
        For example AtomExp.VariableIds("x", [1, 2]) represents "x[1, 2]". 
        """
        ...

    def get_t() -> AtomExp:
        """
        Get t[0] as an AtomExp.
        In general, we default the time variable to t[0],
        to indicate that the number of the â€œclockâ€ is 0.
        """
        ...

    def name(self) -> str: ...
    def vec_ids(self) -> List[int]:
        """get the ordered ids of the atomic expression"""
        ...
    def allids(self) -> Set[int]: ...
    def substs(self, subs: Dict[int, int]) -> AtomExp: ...

class Exp:
    """
    Represents an expression in the language of the AI Physicist.
    Such as "posx[1] + posy[2]", "D[posx[1]]/D[t]", "posx[1] - posy[2]".
    """
    ...

    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> Exp: ...
    def Number(i: int) -> Exp: ...
    def Atom(atom: AtomExp) -> Exp: ...

    def copy(self) -> Exp: ...
    def unwrap_atom(self) -> AtomExp: ...
    @[property]
    def complexity(self) -> int: ...
    def new_variable(self, name: str) -> Exp: ...
    def new_variable_ids(self, name: str, ids: List[int]) -> Exp: ...
    def get_t() -> Exp: ...
    def subst_by_dict(self, subs: Dict[int, int]) -> Exp: ...
    @[property]
    def allids(self) -> Set[int]: ...

    def __add__(self, other: Exp) -> Exp: ...
    def __sub__(self, other: Exp) -> Exp: ...
    def __mul__(self, other: Exp) -> Exp: ...
    def __truediv__(self, other: Exp) -> Exp: ...
    def __neg__(self) -> Exp: ...
    def __powi__(self, other: int) -> Exp: ...
    def __diff__(self, other: Exp) -> Exp: ...
    def __difft__(self, ord: int) -> Exp: ...

class TExp:
    """
    Give a type hint for the `Exp`, to make it a `concept`.
    Such as "(1 -> MassPoint) (2 -> String) |- posx[1] / posr[2]"
    A `concept` can be `specialized` to an `Exp` in a specific experiment.
    """
    ...
    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> TExp: ...
    def Mk0(exp: Exp) -> TExp: ...
    def Mksucc(objtype: str, exp: Exp, id: int) -> TExp: ...

    def subst(self, subs: List[int]) -> Exp: ...
    def subst_by_dict(self, subs: Dict[int, int]) -> Exp: ...
    @[property]
    def exp(self) -> Exp: ...
    @[property]
    def preids(self) -> List[int]: ...
    @[property]
    def objtype_id_map(self) -> Dict[str, Set[int]]: ...

class IExpConfig:
    """
    When we concentrate on a experiment, we can identify the object type and the id.
    `Mkfix` means the the object#id is fixed to `object_name` (refered as standard object).
    `Mk` means the object#id is not fixed, and we can substitute it with any given object of `object_type`
    """
    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> IExpConfig: ...
    def From(exp_name: str) -> IExpConfig: ...
    def Mk(object_type: str, iexpconfig: IExpConfig, id: int) -> IExpConfig: ...
    def Mkfix(object_name: str, iexpconfig: IExpConfig, id: int) -> IExpConfig: ...

    @property
    def expname(self) -> str: ...
    @property
    def objtype_id_map(self) -> Dict[str, Set[int]]: ...
    @property
    def preids(self) -> List[int]: ...

class SExp:
    """
    Combine Expconfig and Exp together, to represent a specialized expression.
    """
    ...
    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> SExp: ...
    def Mk(iexpconfig: IExpConfig, exp: Exp) -> SExp: ...

    @property
    def expconfig(self) -> IExpConfig: ...
    @property
    def exp(self) -> Exp: ...
    @property
    def objtype_id_map(self) -> Dict[str, Set[int]]: ...

class ObjAttrExp:
    """
    Represent an object attribute expression.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, content: str) -> ObjAttrExp: ...
    def From(sexp: SExp) -> ObjAttrExp: ...

class Proposition:
    """
    Represent a proposition in the language of the AI Physicist.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, content: str) -> Proposition: ...
    # not implemented yet

class Expression:
    """
    This class gathers all possible types of expression.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, content: str) -> Expression: ...
    def Exp(exp: Exp) -> Expression: ...
    def SExp(sexp: SExp) -> Expression: ...
    def TExp(texp: TExp) -> Expression: ...
    def ObjAttrExp(objattr: ObjAttrExp) -> Expression: ...
    def Proposition(prop: Proposition) -> Expression: ...
    @[property]
    def expr_type(self) -> str: ...
    @[property]
    def unwrap_exp(self) -> Exp: ...
    @[property]
    def unwrap_sexp(self) -> SExp: ...
    @[property]
    def unwrap_texp(self) -> TExp: ...
    @[property]
    def unwrap_objattrexp(self) -> ObjAttrExp: ...
    @[property]
    def unwrap_proposition(self) -> Proposition: ...



class ExpData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, data: List[List[float]]) -> ExpData: ...
    @[property]
    def is_conserved(self) -> bool: ... # const or zero
    @[property]
    def is_zero(self) -> bool: ...
    @[property]
    def is_err(self) -> bool: ...
    @[property]
    def is_const(self) -> bool: ...
    @[property]
    def normal_data(self) -> NormalData: ...
    @[property]
    def const_data(self) -> ConstData: ...
    def from_elem(mean: float, std: float, n: int, repeat_time: int) -> ExpData: ...
    @[property]
    def n(self) -> int: ...
    @[property]
    def repeat_time(self) -> int: ...

    def __mul__(self, other: ExpData) -> ExpData: ...
    def __truediv__(self, other: ExpData) -> ExpData: ...
    def __add__(self, other: ExpData) -> ExpData: ...
    def __sub__(self, other: ExpData) -> ExpData: ...
    def __neg__(self) -> ExpData: ...
    def __powi__(self, i: int) -> ExpData: ...
    def __diff__(self, other: ExpData) -> ExpData: ...
    def __difftau__(self, other: ExpData) -> ExpData: ...

class NormalData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, data: List[List[float]]) -> NormalData: ...
    def zero(n: int, repeat_time: int) -> NormalData: ...
    def from_elem(mean: float, std: float, n: int, repeat_time: int) -> NormalData: ...
    @[property]
    def data(self) -> List[List[float]]: ...
    @[property]
    def badpts(self) -> Set[int]: ...
    def is_conserved_piecewise(self) -> bool: ...
    @[property]
    def is_conserved(self) -> bool: ...
    @[property]
    def is_zero(self) -> bool: ...

class ConstData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, mean: float, std: float) -> ConstData: ...
    def exact(val: int) -> ConstData: ...

    @[property]
    def mean(self) -> float: ...
    @[property]
    def std(self) -> float: ...
