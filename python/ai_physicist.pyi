from typing import List, Dict, Set, Tuple
from deprecated.sphinx import deprecated

def search_trivial_relations(ds: DataStruct) -> List[Tuple[Exp, ExpData]]:
    """
    Search for trivial relations such as 
    "a = 0", "a = const", or "da/dt = const"
    in the data.
    """
    ...

def search_relations(ds: DataStruct) -> List[Tuple[Exp, ExpData]]:
    """
    Search for simple binary relations in the data.
    """
    ...

def search_relations_ver2(ds: DataStruct) -> List[Tuple[Exp, ExpData]]:
    """
    Search for binary relations between monomials generated from the data.
    such as "m1 * v1 + m2 * v2 = const".
    """
    ...

class Knowledge:
    ...
    def default() -> Knowledge:
        """
        Create a default knowledge object with builtin experiments implemented.
        """
        ...
    def __str__(self) -> str: ...
    def from_string(content: str) -> Knowledge: ...

    # Print the information of the knowledge
    def list_experiments(self): ...
    def list_concepts(self): ...
    def list_conclusions(self): ...

    # Get the information of the knowledge
    @[property]
    def fetch_experiments(self) -> List[str]: ...
    @[property]
    def fetch_concepts(self) -> Dict[str, Expression]: ...
    @[property]
    def fetch_conclusions(self) -> Dict[str, Proposition]: ...
    def fetch_concept_by_name(self, name: str) -> Expression: ...
    def fetch_conclusion_by_name(self, name: str) -> Proposition: ...
    def fetch_object_keys(self) -> Set[str]: ...
    def fetch_object_by_name(self, name: str) -> Objstructure: ...
    def fetch_object_type_by_name(self, name: str) -> str: ...

    # register new knowledge to the current object
    def register_expression(self, name: str, exp: Expression) -> bool: ...
    def register_conclusion(self, name: str, prop: Proposition) -> bool: ...
    def register_object(self, name: str, obj: Objstructure) -> bool: ...
    def remove_conclusion(self, name: str): ...
    def remove_object(self, name: str): ...

    def fetch_expstruct(self, name: str) -> ExpStructure: ...
    def get_expstructure(self, expconfig: IExpConfig, objsettings: List[Objstructure]) -> ExpStructure: ...
    def eval_intrinsic(self, intrinsic: Intrinsic, objsettings: List[Objstructure]) -> ConstData: ...

    def eval(self, exp: Exp, context: ExpStructure) -> ExpData: ...

    def eval_expr_key(self, expr: Expression) -> KeyValueHashed: ...
    def eval_exp_keyvalue(self, exp: Exp) -> KeyValue: ...
    def eval_exp_keyvaluehashed(self, exp: Exp) -> KeyValueHashed: ...

    def generalize_sexp(self, sexp: SExp) -> Concept: ...
    def generalize(self, expr: Exp, exp_name: str) -> Concept: ...
    def specialize(self, concept: Concept, exp_name: str) -> List[Exp]: ...
    def specialize_concept(self, concept_name: str, exp_name: str) -> List[AtomExp]: ...
    def raw_definition(self, expr: Expression) -> Expression: ...
    def raw_definition_prop(self, prop: Proposition) -> Proposition: ...
    def raw_definition_exp(self, exp: Exp) -> Exp: ...

    def parse_atomexp_to_sympy_str(self, input: AtomExp, argument: str) -> str: ...
    def parse_exp_to_sympy_str(self, input: Exp, argument: str) -> str: ...



class ExpStructure:
    """
    一个数据结构，包括实验的配置信息，以及测量数据结果。
    """
    ...
    @property
    def all_ids(self) -> Set[int]: ...
    def get_obj_type(self, id: int) -> str: ...
    def get_obj(self, id: int) -> Objstructure: ...
    @property
    def obj_info(self) -> Dict[str, Tuple[ObjType, int]]: ...
    @property
    def data_info(self) -> DataStruct: ...
    @property
    def spdim(self) -> int: ...

    def random_settings(self): ...
    def random_set_exp_para(self): ...
    def random_set_obj(self, id: int): ...
    def collect_expdata(self, measure_type: MeasureType) -> ExpData: ...

    def copy(self) -> ExpStructure: ...

    @property
    def original_data(self) -> List[AtomExp]: ...   # 实验的原始测量数据的名字，如 t[0], posx[1] 等



class ObjType:
    ...
    def __str__(self) -> str: ...

class Objstructure:
    ...
    def __new__(cls, content: str) -> Objstructure: ...
    def __str__(self) -> str: ...
    def random_settings(self): ...

    # buildin object structures
    def make_masspoint(cls, m_low, m_high): ...
    def make_spring(cls, k_low, k_high, l_low, l_high): ...

class MeasureType:
    ...
    def default() -> MeasureType:
        """
        MeasureType {
            n: 100,
            repeat_time: 100,
            error: 1e-8,
            t_end: 2.0,
        }
        """
        ...
    @property
    def n(self) -> int: ...
    @property
    def repeat_time(self) -> int: ...
    @property
    def error(self) -> float: ...
    @property
    def t_end(self) -> float: ...

class DataStruct:
    ...
    def __str__(self) -> str: ...
    def empty() -> DataStruct: ...

    @[property]
    def data_keys(self) -> Set[AtomExp]: ...

    def fetch_data_by_name_ids(self, name: str, ids: List[int]) -> ExpData: ...
    def fetch_data_by_key(self, atom: AtomExp) -> ExpData: ...
    def fetch_data_by_str(self, key: str) -> ExpData: ...

    def add_data(self, atom: AtomExp, data: ExpData): ...
    def remove_data(self, atom: AtomExp): ...

class AtomExp:
    """
    Represents an atomic expression in the language of the AI Physicist.
    For example, "pos[1]", "r[2, 3]", "t[0]" are all atomic expressions.
    """

    def __new__(cls, content: str) -> AtomExp: ...

    def __str__(self) -> str: ...

    def __hash__(self) -> int: ...

    def VariableIds(name: str, ids: List[int]) -> AtomExp:
        """
        Create an atomic expression with a variable name and a list of ids.
        For example AtomExp.VariableIds("x", [1, 2]) represents "x[1, 2]". 
        """
        ...

    def get_t() -> AtomExp:
        """
        Get t[0] as an AtomExp.
        In general, we default the time variable to t[0],
        to indicate that the number of the “clock” is 0.
        """
        ...

    def name(self) -> str: ...
    def vec_ids(self) -> List[int]:
        """get the ordered ids of the atomic expression"""
        ...
    def allids(self) -> Set[int]: ...
    def substs(self, subs: Dict[int, int]) -> AtomExp: ...

class Exp:
    """
    Represents an expression in the language of the AI Physicist.
    Such as "posx[1] + posy[2]", "D[posx[1]]/D[t]", "posx[1] - posy[2]".
    """
    ...

    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> Exp: ...
    def Number(i: int) -> Exp: ...
    def Atom(atom: AtomExp) -> Exp: ...

    def copy(self) -> Exp: ...
    def unwrap_atom(self) -> AtomExp: ...
    @[property]
    def complexity(self) -> int: ...
    def new_variable(self, name: str) -> Exp: ...
    def new_variable_ids(self, name: str, ids: List[int]) -> Exp: ...
    def get_t() -> Exp: ...
    def subst_by_dict(self, subs: Dict[int, int]) -> Exp: ...
    @[property]
    def allids(self) -> Set[int]: ...

    def __add__(self, other: Exp) -> Exp: ...
    def __sub__(self, other: Exp) -> Exp: ...
    def __mul__(self, other: Exp) -> Exp: ...
    def __truediv__(self, other: Exp) -> Exp: ...
    def __neg__(self) -> Exp: ...
    def __powi__(self, other: int) -> Exp: ...
    def __diff__(self, other: Exp) -> Exp: ...
    def __difft__(self, ord: int) -> Exp: ...
    def DiffExp(exp1: Exp, exp2: Exp, ord: int) -> Exp: ...

class Concept:
    """
    Give a type hint for the `Exp`, to make it a `concept`.
    Such as "(1 -> MassPoint) (2 -> String) |- posx[1] / posr[2]"
    A `concept` can be `specialized` to an `Exp` in a specific experiment.
    """
    ...
    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> Concept: ...
    def Mk0(exp: Exp) -> Concept: ...
    def Mksucc(objtype: str, exp: Exp, id: int) -> Concept: ...

    def subst(self, subs: List[int]) -> Exp: ...
    def subst_by_dict(self, subs: Dict[int, int]) -> Exp: ...
    @[property]
    def exp(self) -> Exp: ...
    @[property]
    def preids(self) -> List[int]: ...
    @[property]
    def objtype_id_map(self) -> Dict[str, Set[int]]: ...

class IExpConfig:
    """
    When we concentrate on a experiment, we can identify the object type and the id.
    `Mkfix` means the the object#id is fixed to `object_name` (refered as standard object).
    `Mk` means the object#id is not fixed, and we can substitute it with any given object of `object_type`
    """
    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> IExpConfig: ...
    def From(exp_name: str) -> IExpConfig: ...
    def Mk(object_type: str, iexpconfig: IExpConfig, id: int) -> IExpConfig: ...
    def Mkfix(object_name: str, iexpconfig: IExpConfig, id: int) -> IExpConfig: ...

    @property
    def expname(self) -> str: ...
    @property
    def objtype_id_map(self) -> Dict[str, Set[int]]: ...
    @property
    def preids(self) -> List[int]: ...
    @property
    def get_relevant_objs(self) -> List[str]: ...

class SExp:
    """
    Combine Expconfig and Exp together, to represent a specialized expression.
    """
    ...
    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> SExp: ...
    def Mk(iexpconfig: IExpConfig, exp: Exp) -> SExp: ...

    @property
    def expconfig(self) -> IExpConfig: ...
    @property
    def exp(self) -> Exp: ...
    @property
    def objtype_id_map(self) -> Dict[str, Set[int]]: ...
    @property
    def get_relevant_objs(self) -> List[str]: ...

class Intrinsic:
    """
    Represent an object attribute expression.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, content: str) -> Intrinsic: ...
    def From(sexp: SExp) -> Intrinsic: ...

    @property
    def relevant_objs(self) -> List[str]: ...

class Proposition:
    """
    Represent a proposition in the language of the AI Physicist.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, content: str) -> Proposition: ...
    # not implemented yet

class Expression:
    """
    This class gathers all possible types of expression.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, content: str) -> Expression: ...
    def Exp(exp: Exp) -> Expression: ...
    def SExp(sexp: SExp) -> Expression: ...
    def Concept(concept: Concept) -> Expression: ...
    def Intrinsic(intrinsic: Intrinsic) -> Expression: ...
    def Proposition(prop: Proposition) -> Expression: ...
    @[property]
    def expr_type(self) -> str: ...
    @[property]
    def unwrap_exp(self) -> Exp: ...
    @[property]
    def unwrap_sexp(self) -> SExp: ...
    @[property]
    def unwrap_concept(self) -> Concept: ...
    @[property]
    def unwrap_intrinsic(self) -> Intrinsic: ...
    @[property]
    def unwrap_proposition(self) -> Proposition: ...


class KeyValue:
    @property
    def is_none(self) -> bool: ...
    @property
    def is_const(self) -> bool: ...
    @property
    def is_zero(self) -> bool: ...


class KeyValueHashed:
    def none(value_len: int, p_mod: int) -> KeyValueHashed: ...
    @property
    def is_none(self) -> bool: ...
    @property
    def is_const(self) -> bool: ...
    @property
    def is_zero(self) -> bool: ...
    @property
    def is_trivial_const(self) -> bool: ...
    @property
    def data(self) -> List[int]: ...

    def insert_description(self, desc: str): ...
    def neg(self) -> KeyValueHashed: ...
    def inv(self) -> KeyValueHashed: ...


class ExpData:
    """
    The major class to represent the data measured in an experiment.
    There are four cases of data:
    1. NormalData: data with noise, with size (n, repeat_time).
    2. ConstData: conserved data (not zero), with mean and std.
    3. ZeroData: zero data.
    4. ErrData: data that has error information (probabily due to crashes between calculations).
    ExpData supports basic operations like +, -, *, /, __powi__.
    ExpData also supports differential operations like __diff__, __difftau__.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, data: List[List[float]]) -> ExpData: ...
    @[property]
    def is_conserved(self) -> bool: ... # const or zero
    @[property]
    def is_zero(self) -> bool: ...
    @[property]
    def is_err(self) -> bool: ...
    @[property]
    def is_const(self) -> bool: ...
    @[property]
    def normal_data(self) -> NormalData: ...
    @[property]
    def const_data(self) -> ConstData: ...
    def from_elem(mean: float, std: float, n: int, repeat_time: int) -> ExpData: ...
    @[property]
    def n(self) -> int: ...
    @[property]
    def repeat_time(self) -> int: ...

    def __mul__(self, other: ExpData) -> ExpData: ...
    def __truediv__(self, other: ExpData) -> ExpData: ...
    def __add__(self, other: ExpData) -> ExpData: ...
    def __sub__(self, other: ExpData) -> ExpData: ...
    def __neg__(self) -> ExpData: ...
    def __powi__(self, i: int) -> ExpData: ...
    def __diff__(self, other: ExpData) -> ExpData: ...
    def __difftau__(self, other: ExpData) -> ExpData: ...

class NormalData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, data: List[List[float]]) -> NormalData: ...
    def zero(n: int, repeat_time: int) -> NormalData: ...
    def from_elem(mean: float, std: float, n: int, repeat_time: int) -> NormalData: ...
    @[property]
    def data(self) -> List[List[float]]: ...
    @[property]
    def badpts(self) -> Set[int]: ...
    def is_conserved_piecewise(self) -> bool: ...
    @[property]
    def is_conserved(self) -> bool: ...
    @[property]
    def is_zero(self) -> bool: ...

class ConstData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, mean: float, std: float) -> ConstData: ...
    def exact(val: int) -> ConstData: ...

    @[property]
    def mean(self) -> float: ...
    @[property]
    def std(self) -> float: ...

    def __add__(self, other: ConstData) -> ConstData: ...
    def __sub__(self, other: ConstData) -> ConstData: ...
    def __mul__(self, other: ConstData) -> ConstData: ...
    def __truediv__(self, other: ConstData) -> ConstData: ...
    def __neg__(self) -> ConstData: ...
    def __powi__(self, i: int) -> ConstData: ...
