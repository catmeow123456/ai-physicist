from typing import List, Dict, Set
from deprecated.sphinx import deprecated

class AtomExp:
    """
    Represents an atomic expression in the language of the AI Physicist.
    For example, "pos[1]", "r[2, 3]", "t[0]" are all atomic expressions.
    """

    def __new__(cls, content: str) -> AtomExp: ...

    def __str__(self) -> str: ...

    def __hash__(self) -> int: ...

    def VariableIds(name: str, ids: List[int]) -> AtomExp:
        """
        Create an atomic expression with a variable name and a list of ids.
        For example AtomExp.VariableIds("x", [1, 2]) represents "x[1, 2]". 
        """
        ...

    def get_t() -> AtomExp:
        """
        Get t[0] as an AtomExp.
        In general, we default the time variable to t[0],
        to indicate that the number of the “clock” is 0.
        """
        ...

    def get_name(self) -> str: ...
    def get_vec_ids(self) -> List[int]:
        """get the ordered ids of the atomic expression"""
        ...
    def get_allids(self) -> Set[int]: ...
    def substs(self, subs: Dict[int, int]) -> AtomExp: ...

class Exp:
    """
    Represents an expression in the language of the AI Physicist.
    """
    ...

    def __str__(self) -> str: ...
    def Number(i: int) -> Exp: ...
    def Atom(atom: AtomExp) -> Exp: ...

    def copy(self) -> Exp: ...
    def unwrap_atom(self) -> AtomExp: ...
    @[property]
    def complexity(self) -> int: ...
    

# class Expression:
#     ...
#     def Exp

class ExpData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, data: List[List[float]]) -> ExpData: ...
    @[property]
    def is_conserved(self) -> bool: ... # const or zero
    @[property]
    def is_zero(self) -> bool: ...
    @[property]
    def is_err(self) -> bool: ...
    @[property]
    def is_const(self) -> bool: ...
    @[property]
    def normal_data(self) -> NormalData: ...
    @[property]
    def const_data(self) -> ConstData: ...
    def from_elem(mean: float, std: float, n: int, repeat_time: int) -> ExpData: ...
    @[property]
    def n(self) -> int: ...
    @[property]
    def repeat_time(self) -> int: ...

    def __mul__(self, other: ExpData) -> ExpData: ...
    def __truediv__(self, other: ExpData) -> ExpData: ...
    def __add__(self, other: ExpData) -> ExpData: ...
    def __sub__(self, other: ExpData) -> ExpData: ...
    def __neg__(self) -> ExpData: ...
    def __powi__(self, i: int) -> ExpData: ...
    def __diff__(self, other: ExpData) -> ExpData: ...
    def __difftau__(self, other: ExpData) -> ExpData: ...

class NormalData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, data: List[List[float]]) -> NormalData: ...
    def zero(n: int, repeat_time: int) -> NormalData: ...
    def from_elem(mean: float, std: float, n: int, repeat_time: int) -> NormalData: ...
    @[property]
    def data(self) -> List[List[float]]: ...
    @[property]
    def badpts(self) -> Set[int]: ...
    def is_conserved_piecewise(self) -> bool: ...
    @[property]
    def is_conserved(self) -> bool: ...
    @[property]
    def is_zero(self) -> bool: ...

class ConstData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, mean: float, std: float) -> ConstData: ...
    def exact(val: int) -> ConstData: ...

    @[property]
    def mean(self) -> float: ...
    @[property]
    def std(self) -> float: ...
